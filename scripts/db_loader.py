# ccc.py - Final working script
import pandas as pd
import cx_Oracle
import sys

# --- 1. Initialize Oracle Client (YOU HAVE SOLVED THIS!) ---
try:
    # Use the exact path that you just confirmed works.
    lib_dir = r"C:\app\ora\instantclient\instantclient_21_19" 
    cx_Oracle.init_oracle_client(lib_dir=lib_dir)
except Exception as e:
    print("‚ùå Error initializing Oracle client:", e)
    sys.exit(1)

print("‚úÖ SUCCESS: Oracle Client initialized successfully!")

# --- 2. Configuration: Update with your details ---
DB_USER = "omega_analyst"
DB_PASSWORD = "omega123" # The password for your omega_analyst user
DB_DSN = "localhost:1521/XEPDB1" 

# --- 3. Load Cleaned Data from CSV ---
try:
    # IMPORTANT: Make sure this CSV file is in the same folder as your script!
    df = pd.read_csv(r'C:\Users\Dar Computers\Desktop\10Acadamy\week 2\Customer_Experience_Analytics_for_Fintech_Apps\task2_sentiment_themes.csv') 
    print(f"‚úÖ Clean CSV data loaded successfully ({len(df)} rows).")
except FileNotFoundError:
    print("‚ùå Error: 'task2_sentiment_themes.csv' not found. Please check the file path.")
    sys.exit()

# --- 4. Main Database Operations ---
connection = None
try:
    connection = cx_Oracle.connect(user=DB_USER, password=DB_PASSWORD, dsn=DB_DSN)
    cursor = connection.cursor()
    print(f"‚úÖ Successfully connected to Oracle Database as '{DB_USER}'")

    print("\nDropping old tables (if they exist) and creating new ones...")
    cursor.execute("BEGIN EXECUTE IMMEDIATE 'DROP TABLE TBL_REVIEWS'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;")
    cursor.execute("BEGIN EXECUTE IMMEDIATE 'DROP TABLE TBL_BANKS'; EXCEPTION WHEN OTHERS THEN IF SQLCODE != -942 THEN RAISE; END IF; END;")
    
    cursor.execute("""
        CREATE TABLE TBL_BANKS (
            BANK_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
            BANK_NAME VARCHAR2(50) NOT NULL UNIQUE,
            PRIMARY KEY (BANK_ID)
        )
    """)
    cursor.execute("""
        CREATE TABLE TBL_REVIEWS (
            REVIEW_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
            BANK_ID NUMBER,
            REVIEW_TEXT CLOB,
            RATING NUMBER(1),
            REVIEW_DATE DATE,
            SOURCE VARCHAR2(50),
            PRIMARY KEY (REVIEW_ID),
            FOREIGN KEY (BANK_ID) REFERENCES TBL_BANKS(BANK_ID)
        )
    """)
    print("‚úÖ Tables 'TBL_BANKS' and 'TBL_REVIEWS' created successfully.")

    print("\nInserting data into tables...")
    
    # === FIX IS APPLIED IN THIS LOOP ===
    bank_id_map = {}
    unique_banks = df['bank'].unique()
    for bank_name in unique_banks:
        # 1. Create a variable to hold the returned ID
        bank_id_var = cursor.var(int)
        
        # 2. Execute, passing the variable to receive the output
        cursor.execute("INSERT INTO TBL_BANKS (BANK_NAME) VALUES (:1) RETURNING BANK_ID INTO :2", 
                       [bank_name, bank_id_var])
                       
        # 3. Get the value from the variable object, not the cursor
        bank_id = bank_id_var.getvalue()[0] 
        bank_id_map[bank_name] = bank_id
    # ==================================
        
    print(f"‚úÖ Inserted {len(bank_id_map)} unique banks into TBL_BANKS.")

    # Prepare data for the second table
    df['bank_id'] = df['bank'].map(bank_id_map)
    df['date'] = pd.to_datetime(df['date'])
    
    # Handle potential nulls or errors before converting to list
    df_insert = df[['bank_id', 'review', 'rating', 'date', 'source']].copy()
    df_insert['review'] = df_insert['review'].astype(str) # Ensure review is a string
    
    reviews_to_insert = [tuple(x) for x in df_insert.to_numpy()]

    # Use executemany for efficient batch insertion
    cursor.executemany("""
        INSERT INTO TBL_REVIEWS (BANK_ID, REVIEW_TEXT, RATING, REVIEW_DATE, SOURCE)
        VALUES (:1, :2, :3, :4, :5)
    """, reviews_to_insert)

    connection.commit()
    print(f"‚úÖ Successfully inserted {cursor.rowcount} records into TBL_REVIEWS.")
    print("\nüéâ Database population complete!")

except cx_Oracle.Error as error:
    print(f"‚ùå Database Error: {error}")
except Exception as e:
    print(f"‚ùå An unexpected error occurred: {e}")
finally:
    if connection:
        connection.close()
        print("\nOracle connection is closed.")